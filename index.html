<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>aarav pillai</title>

<link rel="icon" type="image/png" href="favicon.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root{
  --bg:#ffffff;
  --text:#111;
}

body{
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  max-width:900px;
  margin:0 auto;
  padding:0 24px;
  line-height:1.7;
  color:var(--text);
  background:var(--bg);
}

nav{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:.8rem 0;
}

nav a{
  margin-right:22px;
  text-decoration:none;
  color:#444;
}

h1{
  font-size:2.4em;
  margin:70px 0 20px;
}

canvas{
  width:100%;
  height:420px;
  display:block;
  margin-top:40px;
}

footer{
  margin:80px 0;
  font-size:.85em;
  color:#777;
}
</style>
</head>

<body>

<nav>
  <a href="/">home</a>
  <a href="/research/">research</a>
  <a href="/writing/">writing</a>
  <a href="/photography/">photography</a>
  <a href="/contact/">contact</a>
</nav>

<main>

<h1>hello, i'm aarav pillai (he/him)</h1>

<p>
i work across creative ml, healthcare ai, accessibility, and policy. this diagram is not decorative; it is a small behaving system.
</p>

<canvas id="field"></canvas>

</main>

<footer>
copyright Â© aarav pillai. revised 2026.
</footer>

<script>
const canvas = document.getElementById("field");
const ctx = canvas.getContext("2d");

canvas.width = canvas.offsetWidth;
canvas.height = 420;

/* ---- LOCAL SENTIMENT FIELD ---- */

const policyCorpus = [
  "regulation", "innovation", "risk", "governance",
  "care", "bias", "safety", "equity",
  "surveillance", "infrastructure", "rights"
];

let sentimentEnergy = 0.25;

function updateSentiment(){
  const randomWord = policyCorpus[Math.floor(Math.random()*policyCorpus.length)];

  const chargedWords = ["risk","bias","surveillance"];
  const stabilisingWords = ["care","equity","rights"];

  if(chargedWords.includes(randomWord)){
    sentimentEnergy = 0.45 + Math.random()*0.15;
  } else if(stabilisingWords.includes(randomWord)){
    sentimentEnergy = 0.12 + Math.random()*0.1;
  } else {
    sentimentEnergy = 0.25 + Math.random()*0.1;
  }
}

setInterval(updateSentiment, 6000);
updateSentiment();

/* ---- NODE SYSTEM ---- */

class Node{
  constructor(x,y,r,label,color,freq){
    this.x=x;
    this.y=y;
    this.baseX=x;
    this.baseY=y;
    this.vx=0;
    this.vy=0;
    this.r=r;
    this.label=label;
    this.color=color;
    this.freq=freq;
  }

  update(){
    this.vx += (this.baseX - this.x) * 0.002;
    this.vy += (this.baseY - this.y) * 0.002;

    this.vx += (Math.random()-0.5) * sentimentEnergy;
    this.vy += (Math.random()-0.5) * sentimentEnergy;

    this.vx *= 0.96;
    this.vy *= 0.96;

    this.x += this.vx;
    this.y += this.vy;
  }

  draw(){
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
    ctx.fillStyle=this.color;
    ctx.fill();

    ctx.fillStyle="#111";
    ctx.font="14px system-ui";
    ctx.textAlign="center";
    ctx.fillText(this.label,this.x,this.y+4);
  }

  contains(mx,my){
    return Math.hypot(mx-this.x,my-this.y) < this.r;
  }

  sonify(){
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type="sine";
    osc.frequency.value=this.freq;

    gain.gain.setValueAtTime(0.2,audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+2);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start();
    osc.stop(audioCtx.currentTime+2);
  }
}

const nodes=[
  new Node(180,200,50,"ai policy","#f8d7e8",220),
  new Node(350,120,55,"healthcare ai","#d6ecff",261),
  new Node(400,260,60,"accessibility","#dcf5e9",329),
  new Node(620,200,70,"creative ml","#efe0ff",392)
];

canvas.addEventListener("click",e=>{
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left;
  const my=e.clientY-rect.top;
  nodes.forEach(n=>{
    if(n.contains(mx,my)) n.sonify();
  });
});

function drawConnections(){
  for(let i=0;i<nodes.length;i++){
    for(let j=i+1;j<nodes.length;j++){
      const dx=nodes[i].x-nodes[j].x;
      const dy=nodes[i].y-nodes[j].y;
      const dist=Math.hypot(dx,dy);

      if(dist<260){
        ctx.beginPath();
        ctx.moveTo(nodes[i].x,nodes[i].y);
        ctx.lineTo(nodes[j].x,nodes[j].y);
        ctx.strokeStyle="rgba(0,0,0,"+(1-dist/260)*0.25+")";
        ctx.stroke();
      }
    }
  }
}

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  nodes.forEach(n=>n.update());
  drawConnections();
  nodes.forEach(n=>n.draw());

  requestAnimationFrame(animate);
}

animate();

window.addEventListener("resize",()=>{
  canvas.width=canvas.offsetWidth;
});
</script>

</body>
</html>
